There are certain cases (i.e. Classes and Methods), that may not be extended
with ContextR. These are e.g. some methods in Enumberable, Array and Hash, 
that are used internally in ContextR. Extending them would simply result in 
endless stacks.

In custom classes, i.e. classes defined by your code, every method may be 
extended. There are only 4 exceptions and one corner case.

First the exceptions. You may never extend

* `\_\_id\_\_`
* `\_\_send\_\_`
* `\_\_clone\_\_`
* `extend`

The first shall not be redefined in any case. That is why this triggers a 
warning. The latter is used by ContextR. This currently cannot be circumvented.

`method\_missing`
================

`method\_missing` is the corner case. It is used in ContextR as well, and its
redefinition is difficult, but since the functionality of method missing is 
one of the core ingredients of cleanly designed Ruby programs, it is still 
possible to extend it with context-dependent behaviour. There is one simple
limitation. Do not use `super` to call the next layer, but use `yield(:next)` 
instead.

The following code will show the right usage.

    class MethodMissingExample
      def method_missing(*a)
        "base"
      end

      in_layer :one do
        def method_missing(*a)
          "pre_one " + yield(:next, *a)
        end
      end
      in_layer :two do
        def method_missing(*a)
          yield(:next, *a) + " post_two"
        end
      end
    end

    example do
      instance = MethodMissingExample.new
      result_of(instance.any_method) == "base"

      ContextR::with_layer :one do
        result_of(instance.any_method) == "pre_one base"
      end
      ContextR::with_layer :two do
        result_of(instance.any_method) == "base post_two"
      end

      ContextR::with_layer :one, :two do
        result_of(instance.any_method) == "pre_one base post_two"
      end
    end
